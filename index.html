<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="打开hexo世界的大门">
<meta property="og:type" content="website">
<meta property="og:title" content="邹越的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="邹越的博客">
<meta property="og:description" content="打开hexo世界的大门">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="邹越的博客">
<meta name="twitter:description" content="打开hexo世界的大门">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>邹越的博客</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">邹越的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">小猪快跑</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/02/视频H264编码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="邹越">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邹越的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/02/视频H264编码/" itemprop="url">视频H264编码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-02T16:37:22+08:00">
                2017-07-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>随着无线网络和智能手机的发展，智能手机与人们日常生活联系越来越紧密，娱乐、商务应用、金融应用、交通出行各种功能的软件大批涌现，使得人们的生活丰富多彩、快捷便利，也让它成为人们生活中不可取代的一部分。其中，多媒体由于其直观性和实时性，应用范围越来越广，视频的解码与播放也就成为研究的热点。<br>H.264标准技术日渐成熟，采用了统一的VLC符号编码，高精度、多模式的位移估计，基于4×4块的整数变换、分层的编码语法等。这些措施使得H.264算法具有很高的编码效率，在相同的重建图像质量下，能够比H.263节约50％左右的码率。而且H.264的码流结构网络适应性强，增加了差错恢复能力。正好适用于带宽受限，差错率高的无线网络。<br>本文结合ffmpeg开源代码中的解码方法，采用多线程接收数据包，多级缓冲数据，接收和解码并行双线程操作等方法，缓解了由于传输的数据量大、速度快而导致的数据堵塞、解码出错、视频画面迟钝、延迟等问题。使得h.264视频的传输速度快，稳定性好。最终实现了pc端到android手机端的视频传输，以及在android手机端的解码播放。<br>该技术可以应用于视频会议、视频监控等应用中。</p>
<h2 id="一、-H-264视频传输播放系统的总体结构"><a href="#一、-H-264视频传输播放系统的总体结构" class="headerlink" title="一、 H.264视频传输播放系统的总体结构"></a>一、 H.264视频传输播放系统的总体结构</h2><p>H.264视频传输播放系统分为服务器端和客户端2个部分，服务器端负责读取H.264的视频数据，并且以RTP/RTCP格式打包发送给客户端，并且接受客户端的反馈，对传输速度等作相应的控制。Android手机客户端主要完成从服务器端接收实时码流数据，经过缓冲，进行视频数据解析，然后送去解码，最后在手机上显示播放。服务器端采用c语言实现，客户端主要用java语言实现。</p>
<h2 id="二、关键技术及其实现"><a href="#二、关键技术及其实现" class="headerlink" title="二、关键技术及其实现"></a>二、关键技术及其实现</h2><h3 id="1-基于RTP协议的打包及解包"><a href="#1-基于RTP协议的打包及解包" class="headerlink" title="1.基于RTP协议的打包及解包"></a>1.基于RTP协议的打包及解包</h3><h4 id="（1）单个NAL打包"><a href="#（1）单个NAL打包" class="headerlink" title="（1）单个NAL打包"></a>（1）单个NAL打包</h4><p>H.264NALU单元常由[start code][NALU header][NALU payload]三部分组成，其中start code 用于标志一个NALU单元的开始，必须是“00000001”或者是“000001”，打包时去掉开始码，把其他数据打包到RTP包就可以了。</p>
<h4 id="（2）分片打包"><a href="#（2）分片打包" class="headerlink" title="（2）分片打包"></a>（2）分片打包</h4><p>由于1500个字节是IP数据报的长度的上限，去除20个字节的数据报首部，1480字节是用来存放UDP数据报的。所以当一帧中的字节数超过这个数值时，我们必须将其分片打包。而且UDP在传输的过程中也要由包头开销，所以将RTP包的最大字节数定位1400字节。<br>需要分片的包格式有所区别，首先说明下分片的格式：<br>FU指示字节有以下格式：<br><br>+—————+ <br><br>|0|1|2|3|4|5|6|7|<br><br>+-+-+-+-+-+-+-+-+<br><br>|F|NRI| Type |<br><br>+—————+<br><br>FU指示字节的类型28，29表示FU-A和FU-B。NRI域的值必须根据要分片的NAL单元NRI的值设置。<br><br>FU头的格式如下：<br><br>+—————+<br><br>|0|1|2|3|4|5|6|7|<br><br>+-+-+-+-+-+-+-+-+<br><br>|S|E|R| Type |<br><br>+—————+<br></p>
<p>S：开始位(1bit)，当设置为1，开始位指示分片NAL单元的开始。第一个分片包设为1，其他的分片设置为0。<br>E：结束位(1bit)，当设置为1，结束位指示分片NAL单元的结束，即，FU荷载是最后分片时设置为1，其他时候设置为0。<br>R：保留位(1bit)，必须设置为0。<br>Type：5bit</p>
<h4 id="（3）打包和解包的流程分析："><a href="#（3）打包和解包的流程分析：" class="headerlink" title="（3）打包和解包的流程分析："></a>（3）打包和解包的流程分析：</h4><p>打包：</p>
<p>分片时详细说明：</p>
<ul>
<li>①第一个FU-A包的FU indicator 是这么设置的：F=NALU头中的F，NRI=NALU头中的NRI，Type=28 FU header: S=1，E=0，R=0，Type=NALU头中的Type；</li>
<li>②中间的FU-A包的FU indicator是这么设置的：F=NALU头中的F，NRI=NALU头中的NRI，Type=28 FU header: S=0，E=0，R=0，Type=NALU头中的Type；</li>
<li>③尾FU-A包的FU indicator是这么设置的：F=NALU头中的F，NRI=NALU头中的NRI，Type=28 FU header: S=0，E=1，R=0，Type=NALU头中的Type。</li>
</ul>
<p>解包：<br>下面我们针对RTP解包时对待分片进行分类的代码实现做分析：<br>byte startBit=(byte)(recbuf[13]&amp;0x80); byte endBit=(byte)(recbuf[13]&amp;0x40);</p>
<ul>
<li>①如果，startBit==-128，这包是分片的首包。<br>NalBuf[4]=(byte) ((recbuf[12]&amp;0xE0)+(recbuf[13]&amp;0x1F)); 这句用于重建组合NAL单元类型</li>
<li>②如果(startBit==0)&amp;&amp;(endBit==0)，这包是分片的中间部分。</li>
<li>③如果 endBit==64 ，这包是分片尾部。<br>当分类清楚，就可以对各部分做相应的处理，如图中分析的那样。<h3 id="2-码流管理机制"><a href="#2-码流管理机制" class="headerlink" title="2.码流管理机制"></a>2.码流管理机制</h3><h4 id="1-码流的接收。"><a href="#1-码流的接收。" class="headerlink" title="(1) 码流的接收。"></a>(1) 码流的接收。</h4>在发送端码流发送很快的情况下，由于接收端不仅要接收码流，还要进行分析，解码，这个处理需要一个较长的过程，如果接收端顺序执行这个过程的话，会导致无法完整接收发送端的包、出现丢包，由此而带来的是解码错误、无法正常播放视频、甚至程序奔溃等严重错误。针对这个问题我们采取并发的处理机制予以解决。线程并发存在的一个意义就是为了提高运行在单处理器上的速度。在java中我们采用java.util.concurrent包中的执行器（Executor）来管理线程Thread对象。我们创建20个线程，也就是向SingleThreadExecutor提交了20个任务，这些任务将排好队，每个任务会在下一个任务开始之前运行结束，每个任务都是按照他们被提交的顺序，在下一个任务开始之前完成。这样不仅实现了快速的接收而且还保证了接收到的包顺序是正确的。通过这样的处理后，接收和分析解码可以被分成两个部分，我们可以把接收到的数据暂时存放在缓冲区，然后就可以接着去接收下一包数据，不用等着分析、解码完成后才去接收下一包数据。这样做大大提高了接收效率，同时避免了丢包问题。<h4 id="2-视频数据解析和解码。"><a href="#2-视频数据解析和解码。" class="headerlink" title="(2) 视频数据解析和解码。"></a>(2) 视频数据解析和解码。</h4>由于采用了并发的机制，接收到的数据不止一包，所以对接收到的数据应该做怎样合理的处理，成为我们接下来的难点。我们需要保证的仍然是数据包的顺序，还且每次只能处理一包，这里涉及到一个线程之间的协作问题。我们采用消费者生产者这种线程协作模式来做处理。我们将从存放数据的缓冲区中按顺序取到的包经过分析后放入另外一个缓冲区，通知解码程序可以进行从此缓冲区中获得数据解码，然后分析视频数据的程序进入等待。解码完成后，通知分析视频数据的程序继续进行视频数据分析，同时解码程序又进入等待。两个程序在执行和等待中交替进行。</li>
</ul>
<h4 id="3-多级缓冲机制"><a href="#3-多级缓冲机制" class="headerlink" title="(3) 多级缓冲机制"></a>(3) 多级缓冲机制</h4><p>上面我们也提到了几个缓冲，总结如下。</p>
<ul>
<li>①接收后存放数据的缓冲，由于服务器端源源不断的实时码流，和采用了并发机制后带来更大量的数据，我们不可能马上处理完，所以必须设置一个缓冲区。</li>
<li>②接收端和处理端之间的缓冲，由于网络不稳定，接收到的数据可能会有时快有时慢，这直接会造成解码的不稳定和视频播放的不连续，所以在此设置一个缓冲，起到一个平滑，过渡的作用，这个缓冲区既要存放接收到大量的码流还要为视频数据分析提供数据，有个写读入和读出的过程，所以我们使用先入先出的队列Queue容器来做缓冲区。</li>
<li>③解析和解码过程之间的缓冲，由于在此过程中的数据量相较而言不是很大，而这个获取数据的速度直接影响了解码的速度，所以我们要用一个高效的缓冲区来担当此时的缓冲作用，由于stack是由系统自动分配，所以速度比较快，所以我们就在栈上分配一个数组用于存储即可。</li>
<li>④解码后到播放之间的缓冲，这个缓冲区同样除了起到使播放视频连续稳定的作用外，主要就是用来显示图像，还可以对视频图像进行一些处理工作，平滑，滤波等。<h3 id="3-解码和播放的实现"><a href="#3-解码和播放的实现" class="headerlink" title="3.解码和播放的实现"></a>3.解码和播放的实现</h3>H.264解码是移植了ffmpeg 中的H.264解码部分到Android，并且了深度删减优化。界面部分，文件接收处理以及视频显示都是用java做的，底层的视频解码部分则使用C来做从而满足速度的要求。H.264码流分割NAl（接受到视频数据的复原工作）是在java层做而没有分装到c中，是因为每次送的数据会受到限制，如果送的数据量大，底层可能会一次解码好几帧视频，但是到界面层只能显示一帧，造成丢帧。如果每次送的数据量较少，就会使得多次底层调用但并没有进行实质解码的现象发生，所以尽管这样做耦合度差些，速度慢些，但是综合考虑还是将数据分析工作放在java层完成。</li>
</ul>
<p>我们将解码后的视频数据用bitmap显示，draw到surfaceView的方法显示到手机屏上，由于有些手机不支持rgb24但几乎所有手机都支持rgb565，所以解码后返回的是rgb565数据。</p>
<h2 id="三、结束语"><a href="#三、结束语" class="headerlink" title="三、结束语"></a>三、结束语</h2><p>本文完整的设计并实现了从pc端到android手机端的H.264视频传输与解码播放功能。详细的分析了实现中的技术要点和难点，详细分析了rtp打包，解包的流程，针对发送数据快而处理速度慢的问题，采用多线程并发机制予以解决，面对大量，而且不稳定的数据包，针对各个环节的特点，设置了多级缓冲。使得视频播放更加流畅、平稳。对于分析和解码的先后次序问题，采用线程协作的思想，利用消费者，生产者模式，保证了视频数据的时序性。另外对于解码部分，则利用现有解码方法进行平台移植，合理处理c层和java层的分工，并以实现了这个完整的功能。在网络状况好的情况下，android手机端视频播放延时短，播放流畅，平稳。本文技术研究可以运用到视频播放的各个应用中，有着很强的实用价值。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/30/Miracast原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="邹越">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邹越的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/30/Miracast原理/" itemprop="url">Miracast原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-30T16:06:37+08:00">
                2017-06-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android-Wi-Fi-Display（Miracast）介绍"><a href="#Android-Wi-Fi-Display（Miracast）介绍" class="headerlink" title="Android Wi-Fi Display（Miracast）介绍"></a>Android Wi-Fi Display（Miracast）介绍</h1><p>2012年11月中旬，Google发布了Android 4.2。虽然它和android 4.1同属Jelly Bean系列，但却添加了很多新的功能。其中，在显示部分，Android 4.2在Project Butter基础上再接再厉，新增了对Wi-Fi Display功能的支持。由此也导致整个显示架构发生了较大的变化。<br>本文首先介绍Wi-Fi Display的背景知识，然后再结合代码对Android 4.2中Wi-Fi Display的实现进行介绍。</p>
<h2 id="背景知识介绍"><a href="#背景知识介绍" class="headerlink" title="背景知识介绍"></a>背景知识介绍</h2><p>Wi-Fi Display经常和Miracast联系在一起。实际上，Miracast是Wi-Fi联盟（Wi-Fi Alliance）对支持Wi-Fi Display功能的设备的认证名称。通过Miracast认证的设备将在最大程度内保持对Wi-Fi Display功能的支持和兼容。由此可知，Miracast考察的就是Wi-Fi Display（本文后续将不再区分Miracast和Wi-Fi Display）。而Wi-Fi Display的核心功能就是让设备之间通过Wi-Fi无线网络来分享视音频数据。以一个简单的应用场景为例：有了Wi-Fi Display后，手机和电视机之间可以直接借助Wi-Fi，而无需硬连线（如HDMI）就可将手机中的视频投递到TV上去显示[①]。以目前智能设备的发展趋势来看，Wi-Fi Display极有可能在较短时间内帮助我们真正实现多屏互动。<br>从技术角度来说，Wi-Fi Display并非另起炉灶，而是充分利用了现有的Wi-Fi技术。图1所示为Wi-Fi Display中使用的其他Wi-Fi技术项。</p>
<p><img src="http://img.my.csdn.net/uploads/201301/06/1357478712_8403.png" alt=""></p>
<p>由图1可知，Miracast依赖的Wi-Fi技术项有：</p>
<ul>
<li>Wi-Fi Direct，也就是Wi-Fi P2P。它支持在没有AP（Access Point）的情况下，两个Wi-Fi设备直连并通信。</li>
<li>Wi-Fi Protected Setup：用于帮助用户自动配置Wi-Fi网络、添加Wi-Fi设备等。</li>
<li>11n/WMM/WPA2：其中，11n就是802.11n协议，它将11a和11g提供的Wi-Fi传输速率从56Mbps提升到300甚至600Mbps。WMM是Wi-Fi Multimedia的缩写，是一种针对实时视音频数据的QoS服务。而WPA2意为Wi-Fi Protected Acess第二版，主要用来给传输的数据进行加密保护。</li>
</ul>
<p>上述的Wi-Fi技术中，绝大部分功能由硬件厂商实现。而在Android中，对Miracast来说最重要的是两个基础技术：</p>
<ul>
<li>Wi-Fi Direct：该功能由Android中的WifiP2pService来管理和控制。</li>
<li>Wi-Fi Multimedia：为了支持Miracast，Android 4.2对MultiMedia系统也进行了修改。</li>
</ul>
<p>下边我们对Miracast几个重要知识点进行介绍，首先是拓扑结构和视音频格式方面的内容。<br>Miracast一个重要功能就是支持Wi-Fi Direct。但它也考虑了无线网络环境中存在AP设备的情况下，设备之间的互联问题。读者可参考如图2所示的四种拓扑结构。</p>
<p><img src="http://img.my.csdn.net/uploads/201301/06/1357478739_2291.png" alt=""></p>
<p>在Wi-Fi Display规范中，还存在着Source将Video和Audio内容分别传送给不同Render Device的情况.另外，Miracast对所支持的视音频格式也进行了规定:</p>
<ul>
<li>分辨率<br>17种 CEA格式，分辨率从640<em>480到1920</em>1080，帧率从24到60<br>29种VESA格式，分辨率从800<em>600到1920</em>1200，帧率从30到60<br>12种手持设备格式，分辨率从640<em>360到960</em>540，帧率从30到60</li>
<li>视频<br>H.264高清<br>音频<br>必选：LPCM 16bits，48kHz采样率，双声道<br>可选：<br>LPCM 16bits，44.1kHz采样率，双声道<br>Advanced Audio coding<br>Dolby Advanced Codec 3</li>
</ul>
<p>最后，我们简单介绍一下Miracast的大体工作流程。Miracast以session为单位来管理两个设备之间的交互的工作，主要步骤包括（按顺序）：</p>
<ul>
<li>Device Discovery：通过Wi-Fi P2P来查找附近的支持Wi-Fi P2P的设备。</li>
<li>Device Selection：当设备A发现设备B后，A设备需要提示用户。用户可根据需要选择是否和设备B配对。</li>
<li>Connection Setup：Source和Display设备之间通过Wi-Fi P2P建立连接。根据Wi-Fi Direct技术规范，这个步骤包括建立一个Group Owner和一个Client。此后，这两个设备将建立一个TCP连接，同时一个用于RTSP协议的端口将被创建用于后续的Session管理和控制工作。</li>
<li>Capability Negotiation：在正式传输视音频数据前，Source和Display设备需要交换一些Miracast参数信息，例如双方所支持的视音频格式等。二者协商成功后，才能继续后面的流程。</li>
<li>Session Establishment and streaming：上一步工作完成后，Source和Display设备将建立一个Miracast Session。而后就可以开始传输视音频数据。Source端的视音频数据将经由MPEG2TS编码后通过RTP协议传给Display设备。Display设备将解码收到的数据，并最终显示出来。</li>
<li>User Input back channel setup：这是一个可选步骤。主要用于在传输过程中处理用户发起的一些控制操作。这些控制数据将通过TCP在Source和Display设备之间传递。</li>
<li>Payload Control：传输过程中，设备可根据无线信号的强弱，甚至设备的电量状况来动态调整传输数据和格式。可调整的内容包括压缩率，视音频格式，分辨率等内容。</li>
<li>Session teardown：停止整个Session。</li>
</ul>
<p>通过对上面背景知识的介绍，读者可以发现：</p>
<ul>
<li>Miracast本质就是一个基于Wi-Fi的网络应用。这个应用包括服务端和客户端。</li>
<li>服务端和客户端必须支持RTP/RTSP等网络协议和相应的编解码技术。</li>
</ul>
<h2 id="Android-4-2-Miracast功能实现介绍"><a href="#Android-4-2-Miracast功能实现介绍" class="headerlink" title="Android 4.2 Miracast功能实现介绍"></a>Android 4.2 Miracast功能实现介绍</h2><p>Miracast的Android实现涉及到系统的多个模块，包括：</p>
<ul>
<li>MediaPlayerService及相关模块：原因很明显，因为Miracast本身就牵扯到RTP/RTSP及相应的编解码技术。</li>
<li>SurfaceFlinger及相关模块：SurfaceFlinger的作用是将各层UI数据混屏并投递到显示设备中去显示。现在，SurfaceFlinger将支持多个显示设备。而支持Miracast的远端设备也做为一个独立的显示设备存在于系统中。</li>
<li>WindowManagerService及相关模块：WindowManagerService用于管理系统中各个UI层的位置和属性。由于并非所有的UI层都会通过Miracast投递到远端设备上。例如手机中的视频可投递到远端设备上去显示，但假如在播放过程中，突然弹出一个密码输入框（可能是某个后台应用程序发起的），则这个密码输入框就不能投递到远端设备上去显示。所以，WindowManagerService也需要修改以适应Miracast的需要。</li>
<li>DisplayManagerService及相关模块：DisplayManagerService服务是Android 4.2新增的，用于管理系统中所有的Display设备。</li>
</ul>
<p>由于篇幅原因，本文将重点关注SurfaceFlinger和DisplayManagerService以及Miracast的动态工作流程。<br>相比前面的版本，Android 4.2中SurfaceFlinger的最大变化就是增加了一个名为DisplayDevice的抽象层。<br><img src="http://img.my.csdn.net/uploads/201301/06/1357478758_9825.png" alt=""></p>
<p>可知：</p>
<ul>
<li>Surface系统定义了一个DisplayType的枚举，其中有代表手机屏幕的DISPLAY_PRIMARY和代表HDMI等外接设备的DISPLAY_EXTERNAL。比较有意思的是，作为Wi-Fi Display，它的设备类型是DISPLAY_VIRTUAL。</li>
<li>再来看SurfaceFlinger类，其内部有一个名为mDisplays的变量，它保存了系统中当前所有的显示设备（DisplayDevice）。另外，SurfaceFlinger通过mCurrentState和mDrawingState来控制显示层的状态。其中，mDrawingState用来控制当前正在绘制的显示层的状态，mCurrentState表示当前所有显示层的状态。有这两种State显示层的原因是不论是Miracast还是HDMI设备，其在系统中存在的时间是不确定的。例如用户可以随时选择连接一个Miracast显示设备。为了不破坏当前正在显示的内容，这个新显示设备的一些信息将保存到CurrentState中。等到SurfaceFlinger下次混屏前再集中处理。</li>
<li>mCurrentState和mDrawingState的类型都是SurfaceFlinger的内部类State。由图3可知，State首先通过layerSortedByZ变量保存了一个按Z轴排序的显示层数组（在Android中，显示层的基类是LayerBase），另外还通过displays变量保存了每个显示层对应的DisplayDeviceState。</li>
<li>DisplayDeviceState的作用是保存对应显示层的DisplayDevice的属性以及一个ISurfaceTexure接口。这个接口最终将传递给DisplayDevice。<br>DisplayDevice代表显示设备，它有两个重要的变量，一个是mFrameBufferSurface和mNativeWindow。mFrameBufferSurace是FrameBufferSurface类型，当显示设备不属于VIRTUAL类型的话，则该变量不为空。对于Miracast来说，显示数据是通过网络传递给真正的显示设备的，所有在Source端的SurfaceFlinger来说，就不存在FrameBuffer。故当设备为VIRTUAL时，其对应的mFrameBufferSurface就为空。而ANativeWindow是Android显示系统的老员工了。该结构体在多媒体的视频I/O、OpenGL ES等地方用得较多。而在普通的UI绘制中，ISurfaceTexture接口用得较多。不过早在Android 2.3，Google开发人员就通过函数指针将ANativeWindow的各项操作和ISurfaceTexture接口统一起来。</li>
</ul>
<p>作为VIRTUAL的Miracast设备是如何通过DisplayDevice这一层抽象来加入到Surface系统中来的呢？下面这段代码对理解DisplayDevice的抽象作用极为重要</p>
<p><img src="http://img.my.csdn.net/uploads/201301/06/1357478788_3356.png" alt=""></p>
<p>可知：</p>
<ul>
<li>对于非Virtual设备，DisplayDevice的FrameBufferSurface不为空。而且SurfaceTextureClient的构造参数来自于FrameBufferSurface的getBufferQueue函数。</li>
<li>如果是Virtual设备，SurfaceTextureClient直接使用了State信息中携带的surface变量。</li>
</ul>
<p>凭着上面这两点不同，我们可以推测出如图5所示的DisplayDevice的作用:<br><img src="http://img.my.csdn.net/uploads/201301/06/1357478805_4074.png" alt=""></p>
<p>最后再来看一下SurfaceFlinger中混屏操作的实现:</p>
<p><img src="http://img.my.csdn.net/uploads/201301/06/1357478824_6904.png" alt=""></p>
<p>SurfaceFlinger将遍历系统中所有的DisplayDevice来完成各自的混屏工作。</p>
<h2 id="Framework对Miracast的支持"><a href="#Framework对Miracast的支持" class="headerlink" title="Framework对Miracast的支持"></a>Framework对Miracast的支持</h2><p>为了彻底解决多显示设备的问题，Android 4.2干脆在Framework中新增了一个名为DisplayManagerService的服务，用来统一管理系统中的显示设备。DisplayManagerService和系统其它几个服务都有交互。整体结构如图:<br><img src="http://img.my.csdn.net/uploads/201301/06/1357478840_5925.png" alt=""><br>可知：</p>
<ul>
<li>DisplayManagerService主要实现了IDisplayManager接口。这个接口的大部分函数都和Wi-Fi Display操作相关。</li>
<li>另外，DisplayManagerService和WindowManagerService交互紧密。因为WindowManagerService管理系统所有UI显示，包括属性，Z轴位置等等。而且，WindowManagerService是系统内部和SurfaceFlinger交互的重要通道。</li>
<li>DisplayManagerService通过mDisplayAdapters来和DisplayDevice交互。每一个DisplayDevice都对应有一个DisplayAdapter。</li>
<li>系统定义了四种DisplayAdapter。HeadlessDisplayAdapter和OverlayDisplayAdapter针对的都是Fake设备。其中OverlayDisplay用于帮助开发者模拟多屏幕之用。LocalDisplayAdapter代表主屏幕，而WifiDisplayAdapter代表Wi-Fi Display。</li>
</ul>
<h2 id="Android中Miracast动态工作流程介绍"><a href="#Android中Miracast动态工作流程介绍" class="headerlink" title="Android中Miracast动态工作流程介绍"></a>Android中Miracast动态工作流程介绍</h2><p>当用户从Settings程序中选择开启Miracast并找到匹配的Device后，系统将通过WifiDisplayController的requestConnect函数向匹配设备发起连接。<br><img src="http://img.my.csdn.net/uploads/201301/06/1357478857_7139.png" alt=""><br>最终将调用connect函数去连接指定的设备。connect函数比较中，其中最重要的是updateConnection函数，我们抽取其中部分代码来看:<br><img src="http://img.my.csdn.net/uploads/201301/06/1357478872_3803.png" alt=""></p>
<p>系统创建了一个RemoteDisplay，并在这个Display上监听（listen）。从注释中可知，该RemoteDisplay就是和远端Device交互的RTP/RTSP通道。而且，一旦有远端Device连接上，还会通过onDisplayConnected返回一个Surface对象。<br>根据前面对SurfaceFlinger的介绍，读者可以猜测出Miracast的重头好戏就在RemoteDisplay以及它返回的这个Surface上了。<br>确实如此，RemoteDisplay将调用MediaPlayerService的listenForRemoteDisplay函数，最终会得到一个Native的RemoteDisplay对象。</p>
<p><img src="http://img.my.csdn.net/uploads/201301/06/1357478888_7208.png" alt=""></p>
<p>RemoteDisplay有三个重要成员变量：</p>
<ul>
<li>mLooper，指向一个ALooper对象。这表明RemoteDisplay是一个基于消息派发和处理的系统。</li>
<li>mNetSession指向一个ANetWorkSession对象。从它的API来看，ANetworkSession提供大部分的网络操作。</li>
<li>mSource指向一个WifiDisplaySource对象。它从AHandler派生，故它就是mLooper中消息的处理者。注意，图中的M1、M3、M5等都是Wi-Fi Display技术规范中指定的消息名。</li>
</ul>
<p>RemoteDisplay构造函数中，WifiDisplaySource的start函数将被调用。如此，一个类型为kWhatStart的消息被加到消息队列中。该消息最终被WifiDisplaySource处理，结果是一个RTSPServer被创建。<br><img src="http://img.my.csdn.net/uploads/201301/06/1357478903_7919.png" alt=""></p>
<p>以后，客户端发送的数据都将通过类型为kWhatRTSPNotify的消息加入到系统中来。而这个消息的处理核心在onReceiveClientData函数中，它囊括了设备之间网络交互的所有细节。<br><img src="http://img.my.csdn.net/uploads/201301/06/1357478917_9353.png" alt=""></p>
<p>以后，客户端发送的数据都将通过类型为kWhatRTSPNotify的消息加入到系统中来。而这个消息的处理核心在onReceiveClientData函数中，它囊括了设备之间网络交互的所有细节。</p>
<p><img src="http://img.my.csdn.net/uploads/201301/06/1357478917_9353.png" alt=""></p>
<p>根据前面的背景知识介绍，设备之间的交互将由Session来管理。在代码中，Session的概念由WifiSource的内部类PlaybackSession来表示。先来看和其相关的类图结构:<br><img src="http://img.my.csdn.net/uploads/201301/06/1357478932_9334.png" alt=""></p>
<p>可知：</p>
<ul>
<li>PlaybackSession及其内部类Track都从AHandler派生。故它们的工作也依赖于消息循环和处理。Track代表视频流或音频流。</li>
<li>Track内部通过mMediaPull变量指向一个MediaPull对象。而MediaPull对象则保存了一个MediaSource对象。在PlaybackSession中，此MediaSource的真正类型为SurfaceMediaSource。它表明该Media的源来自Surface。</li>
<li>BufferQueue从ISurfaceTexure中派生，根据前面对SurfaceFlinger的介绍，它就是SurfaceFlinger代码示例中代表虚拟设备的State的surface变量。</li>
</ul>
<p>当双方设备准备就绪后，MediaPull会通过kWhatPull消息处理不断调用MediaSource的read函数。在SurfaceMediaSource实现的read函数中，来自SurfaceFlinger的混屏后的数据经由BufferQueue传递到MediaPull中。<br><img src="http://img.my.csdn.net/uploads/201301/06/1357478945_6837.png" alt=""></p>
<p>可知：</p>
<ul>
<li>MediaPull通过kWhatPull消息不断调用MediaSource的read函数。</li>
<li>SurfaceMediaSource的read函数由通过mBufferQueue来读取数据。</li>
</ul>
<p>那么mBufferQueue的数据来自什么地方呢？对，正是来自图4的SurfaceFlinger。<br>当然，PlaybackSession拿到这些数据后还需要做编码，然后才能发送给远端设备。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对Miracast的背景知识以及Android系统中Miracast的实现进行了一番简单介绍。从笔者个人角度来看，有以下几个点值得感兴趣的读者注意：</p>
<ul>
<li>一定要结合Wi-Fi的相关协议去理解Miracast。重点关注的协议包括Wi-Fi P2p和WMM。</li>
<li>Android Miracast的实现中，需要重点理解SurfaceFlinger和RemoteDisplay模块。这部分的实现不仅代码量大，而且类之间，以及线程之间关系复杂。</li>
<li>其他需要注意的点就是DisplayManagerService及相关模块。这部分内容在SDK中有相关API。应用开发者应关注这些新API是否能帮助自己开发出更有新意的应用程序。</li>
</ul>
<p>另外，Android的进化速度非常快，尤其在几个重要的功能点上。作者在此也希望国内的手机厂商或那些感兴趣的移动互联网厂商能真正投入力量做一些更有深度和价值的研发工作。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/27/安卓BLE开发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="邹越">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邹越的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/27/安卓BLE开发/" itemprop="url">安卓BLE开发</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-27T14:38:15+08:00">
                2017-06-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是BLE"><a href="#什么是BLE" class="headerlink" title="什么是BLE"></a>什么是BLE</h1><p>BLE全称Bluetooth Low Energy，即蓝牙低功耗。蓝牙4.0才支持BLE，蓝牙4.0向下兼容，包括传统蓝牙技术、高速技术和低耗能技术三种规格。主要用于手机与周边设备进行通信，当然也可以用于所有BLE设备之间的通信。使用BLE可以实现Android与iOS之间的蓝牙通信，而普通蓝牙却不可以。<br>BLE利用了许多技术来降低功耗，了解这些技术可以解决许多开发问题。下面分享一下我所了解的知识：</p>
<h2 id="连接间隔"><a href="#连接间隔" class="headerlink" title="连接间隔"></a>连接间隔</h2><p>BLE采用可变的连接间隔，也就是两个事件之间的间隔，间隔时间以1.25ms为单位。<br>当有数据进行传输时，必须要等到下一个事件的发生。所以间隔时间越长，事件发生的频率也就越低，传输速率就越慢，功耗就越低，反之亦然。<br>当然它也有取值范围，连接间隔的值为6(7.5ms)~3200(4s)。android手机规定连接参数最小是8，即10毫秒。ios规定是16，即20毫秒。</p>
<h2 id="数据包长度"><a href="#数据包长度" class="headerlink" title="数据包长度"></a>数据包长度</h2><p>BLE数据包的结构跟协议有关，这里就不分析了。<br>BLE数据包中有效数据的最大长度是27字节，但这27字节指的是BLE底层的协议包格式。<br>对于profile层的characteristic（后面会讲到），其最大的长度是20字节，也就是每个包最大的长度是20字节。</p>
<h2 id="传输速度"><a href="#传输速度" class="headerlink" title="传输速度"></a>传输速度</h2><p>Android的BLE最快传输速度：20Byte/0.01s=2KB/s。<br>但有个原则：只在必要时（传输较大的数据），才缩短连接间隔。并且当数据传输完毕后，还原连接间隔。<br>因为缩短间隔会增大功耗，降低电池使用寿命。</p>
<h2 id="组网方式"><a href="#组网方式" class="headerlink" title="组网方式"></a>组网方式</h2><p>蓝牙系统采用一种灵活的无基站的组网方式，使得一个蓝牙设备可同时与7个其它的蓝牙设备相连接。蓝牙系统的网络结构的拓扑结构有两种形式：微微网（piconet）和分布式网络（Scatternet）。<br>一个蓝牙网络由一个主设备和一个或多个从属设备组成，它们都与主设备的时间和跳频模式同步（以主设备的时钟和蓝牙设备的地址为准）。每个独立的同步蓝牙网络就被称为一个微微网（piconet），有一个主设备单元和最多7个从设备单元。<br>所以BLE支持两种角色，主设备（Master）和从设备（Slave）。Master可以同时与多个设备通信；Slave只能和一个Master通信。</p>
<h2 id="BLE通信协议-GATT"><a href="#BLE通信协议-GATT" class="headerlink" title="BLE通信协议-GATT"></a>BLE通信协议-GATT</h2><p>GATT协议结构</p>
<p>BLE技术是基于GATT进行通信的，GATT(Generic Attribute Profile)是一种属性传输协议，简单的讲可以认为是一种属性传输的应用层协议。它的结构非常简单：</p>
<p>GATT结构图</p>
<p><img src="http://img.blog.csdn.net/20170406164847889?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2FrZXJfamluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>结构的组成：</p>
<ul>
<li>每个BLE设备由多个Profile（GATT）组成</li>
<li>每个Profile由多个的Service服务组成</li>
<li>每个Service由多个Characteristic特征组成</li>
<li>每个Characteristic由一个Value值和多个Descriptor描述组成<br>结构的用途：</li>
</ul>
<p>Service用于数据的分类<br>Characteristic用于存放属性<br>Value是Characteristic的属性值。而Descriptor则是对Value不同角度的描述和说明，所以有多个Descriptor<br>GATT基础知识</p>
<p>GATT通信的双方是C/S关系。外设作为 GATT 服务端（Server），它维持了 ATT 的查找表以及 service 和 characteristic 的定义。中心设备是 GATT 客户端（Client），它向 Server 发起请求。需要注意的是，所有的通信事件，都是由客户端（也叫主设备，Master）发起，并且接收服务端（也叫从设备，Slave）的响应。</p>
<p>GATT连接是独占的。也就是一个BLE外设同时只能被一个中心设备连接。一旦外设被连接，它就会马上停止广播，这样它就对其他设备不可见了。当设备断开，它又开始广播。</p>
<p>Service、Characteristic和Descriptor均有一个唯一的UUID标识，UUID既有16位的也有128位的。16位的UUID是经过蓝牙组织认证的，是需要购买的，而128位的UUID则可以自定义，当然也有许多通用的UUID。</p>
<p>##小结</p>
<p>如果开发BLE的兄弟们直接去看官方Demo，肯定会有许多疑问。比如，这个方法什么时候回调、那个变量是干什么用的。希望开发者先通过本文了解一下BLE的工作流程，再着手撸代码，许多问题就会迎刃而解。</p>
<p><a href="http://blog.csdn.net/saker_jing/article/details/69407786" title="转自SakerJing的博客" target="_blank" rel="external">http://blog.csdn.net/saker_jing/article/details/69407786</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/25/Mr-Blue-sky/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="邹越">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邹越的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/25/Mr-Blue-sky/" itemprop="url">Nice to meet you,Mr Blue sky!</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-25T17:21:21+08:00">
                2017-05-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://cdn.clickme.net/Gallery/2014/08/28/07826f521139b311a180a6d5fb7631d9.gif" alt="小树人"></p>
<p><em>-SHARING-</em></p>
<h2 id="雾霾笼罩下的大都市，Mr-Blue-Sky你在哪里？"><a href="#雾霾笼罩下的大都市，Mr-Blue-Sky你在哪里？" class="headerlink" title="雾霾笼罩下的大都市，Mr Blue Sky你在哪里？"></a>雾霾笼罩下的大都市，Mr Blue Sky你在哪里？</h2><h1 id="Mr-Blue-sky"><a href="#Mr-Blue-sky" class="headerlink" title="Mr Blue sky"></a><em>Mr Blue sky</em></h1><p><embed autostart="true" hidden="true" loop="true" src="http://ois5yh1xg.bkt.clouddn.com/%E5%8D%A2%E5%86%A0%E5%BB%B7%E4%B8%80%E7%94%9F%E6%89%80%E7%88%B1.mp3"></p>
<ul>
<li>Sun is shinin’ in the sky</li>
<li>太阳当空高照</li>
<li>There ain’t a cloud in sight</li>
<li>晴天万里无云</li>
<li>It’s stopped rainin’</li>
<li>阴雨连绵不再</li>
<li>Everybody’s in their play</li>
<li>人人笑逐颜开</li>
<li>And don’t you know</li>
<li>你可知道</li>
<li>It’s a beautiful new day</li>
<li>今天这个日子</li>
<li>妙哉，妙哉</li>
<li>Hey hey hey</li>
<li>嘿嘿嘿</li>
<li>Runnin’ down the avenue pant</li>
<li>沿着林荫大道走来</li>
<li>See how the sun shines</li>
<li>看太阳光芒万丈</li>
<li>Brightly in the city</li>
<li>阳光在城市散开</li>
<li>On the streets where once was pity</li>
<li>这些街道曾经很悲哀</li>
<li>Mr  Blue Sky is living here today</li>
<li>蓝天先生今天你与我们同在</li>
<li>Hey  hey  hey</li>
<li>嘿嘿嘿</li>
<li>Mr  Blue Sky  please tell us why</li>
<li>蓝天先生，请讲明白</li>
<li>You had to hide away</li>
<li>过去的你，为何离开</li>
<li>For so long，so long, where did we go wrong</li>
<li>我们做错了什么，要这样苦苦等待</li>
<li>Mr  Blue Sky  please tell us why</li>
<li>蓝天先生，请讲明白</li>
<li>You had to hide away</li>
<li>过去的你，为何离开</li>
<li>For so long, so long, where did we go wrong</li>
<li>我们做错了什么，要这样苦苦等待</li>
<li>Hey  you with the pretty face</li>
<li>嘿，你，美丽动人的那一位</li>
<li>Welcome to the human race</li>
<li>欢迎加入我们人类</li>
<li>A celebration</li>
<li>一起来庆祝</li>
<li>Mr  Blue Sky’s up there waitin’</li>
<li>蓝天先生在天上迫不及待，And today</li>
<li>我们期盼的日子</li>
<li>Is the day we’ve waited for</li>
<li>终于到来</li>
<li>Oh  oh  oh</li>
<li>噢噢噢</li>
<li>Mr  Blue Sky  please tell us why</li>
<li>蓝天先生，请讲明白</li>
<li>You had to hide away</li>
<li>过去的你，为何离开</li>
<li>For so long, so long, where did we go wrong</li>
<li>我们做错了什么，要这样苦苦等待</li>
<li>Hey  there Mr  Blue</li>
<li>嘿，蓝天先生</li>
<li>We’re so pleased to be with you</li>
<li>如今很荣幸与你同在</li>
<li>Look around see what you do</li>
<li>看看四周你带来的一切</li>
<li>Everybody smiles at you</li>
<li>人人冲你喜笑颜开</li>
<li>Hey  there Mr  Blue We’re so</li>
<li>嘿，蓝天先生</li>
<li>Pleased to be with you</li>
<li>我们很荣幸与你同在</li>
<li>Look around see what you do</li>
<li>看看四周你带来的一切</li>
<li>Everybody smiles at you</li>
<li>人人冲你喜笑颜开</li>
<li>Mr  Blue  you did it right</li>
<li>蓝天先生你真不赖</li>
<li>But soon comes Mr  Night</li>
<li>但是黑夜先生就要到来</li>
<li>Creepin’ over</li>
<li>哭哭啼啼</li>
<li>Now his hand is on your shoulder</li>
<li>把手往你肩上一甩</li>
<li>Never mind  I’ll remember you this</li>
<li>没关系，我会永远记住你</li>
<li>I’ll remember you way this</li>
<li>你的温暖，你的存在</li>
<li>Mr  Blue Sky  please tell us why</li>
<li>蓝天先生，请讲明白</li>
<li>You had to hide away</li>
<li>过去的你，为何离开</li>
<li>For so long, so long, where did we go wrong</li>
<li>我们做错了什么，要这样苦苦等待</li>
<li>Hey  there Mr  Blue We’re so</li>
<li>嘿，蓝天先生</li>
<li>Pleased to be with you</li>
<li>今天很荣幸与你同在</li>
<li>Look around see what you do</li>
<li>看看四周你带来的一切</li>
<li>Everybody smiles at you</li>
<li>人人冲你喜笑颜开</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/25/run/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="邹越">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邹越的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/25/run/" itemprop="url">小猪快跑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-25T17:14:07+08:00">
                2017-05-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://img.blog.csdn.net/20170525122650067?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2Q4Mzc2OTQwMzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="小猪快跑"></p>
<p>假如生活欺骗了你，不要悲伤，不要心急，没准是你活该呢。哈哈哈，一口毒奶。</p>
<p><img src="http://anatole.munen.cc/assets/wallpaper-2572384.jpg" alt="LITTLE CAT"></p>
<p><img src="http://anatole.munen.cc/assets/wallpaper-2311325.jpg" alt="LITTLE GIRL"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="邹越" />
          <p class="site-author-name" itemprop="name">邹越</p>
           
              <p class="site-description motion-element" itemprop="description">打开hexo世界的大门</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">邹越</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
